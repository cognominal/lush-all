from __future__ import annotations

import json
import subprocess
from dataclasses import dataclass
from pathlib import Path
from typing import Any

from manim import DOWN, Create, FadeIn, FadeOut, ImageMobject, MovingCameraScene, Rectangle, Text, WHITE, YELLOW
from manim import config


# Represent one extracted component box and metadata.
@dataclass(frozen=True)
class ComponentData:
    name: str
    x: float
    y: float
    w: float
    h: float
    caption: str
    svelte_component_name: str | None
    inner_components: list["ComponentData"]


# Build typed ComponentData recursively from raw dict input.
def parse_component(raw: dict[str, Any]) -> ComponentData:
    inner_raw = raw.get("innerComponents", [])
    inner = [parse_component(item) for item in inner_raw if isinstance(item, dict)]
    return ComponentData(
        name=str(raw.get("name", "Component")),
        x=float(raw.get("x", 0)),
        y=float(raw.get("y", 0)),
        w=float(raw.get("w", 1)),
        h=float(raw.get("h", 1)),
        caption=str(raw.get("caption", raw.get("name", "Component"))),
        svelte_component_name=(
            str(raw["svelteComponent"])
            if isinstance(raw.get("svelteComponent"), str)
            else (
                str(raw["svelteComponentName"])
                if isinstance(raw.get("svelteComponentName"), str)
                else None
            )
        ),
        inner_components=inner,
    )


# Load a component list from a JSON file generated by the extractor script.
def load_components(path: str) -> list[ComponentData]:
    data = json.loads(Path(path).read_text(encoding="utf-8"))
    if not isinstance(data, list):
        raise ValueError("Expected top-level JSON array of components.")
    return [parse_component(item) for item in data if isinstance(item, dict)]


# Flatten nested components into a deterministic display order.
def flatten_components(components: list[ComponentData]) -> list[ComponentData]:
    ordered: list[ComponentData] = []
    for component in components:
        ordered.append(component)
        ordered.extend(flatten_components(component.inner_components))
    return ordered


# Convert top-left screenshot pixel coordinates into scene-space rectangle.
def component_rect_on_image(
    image: ImageMobject,
    component: ComponentData,
    image_width_px: float,
    image_height_px: float,
) -> Rectangle:
    scale_x = image.width / image_width_px
    scale_y = image.height / image_height_px
    width_scene = component.w * scale_x
    height_scene = component.h * scale_y
    center_x = image.get_left()[0] + (component.x + component.w / 2.0) * scale_x
    center_y = image.get_top()[1] - (component.y + component.h / 2.0) * scale_y
    rect = Rectangle(width=max(width_scene, 0.02), height=max(height_scene, 0.02))
    rect.move_to([center_x, center_y, 0])
    return rect


# Animate one component focus cycle: highlight, zoom/fade, dezoom/restore.
def focus_component(
    scene: MovingCameraScene,
    image: ImageMobject,
    component: ComponentData,
    image_width_px: float,
    image_height_px: float,
    fade_opacity: float = 0.2,
    zoom_padding: float = 1.35,
    zoom_duration: float = 1.1,
    hold_duration: float = 0.5,
) -> None:
    rect = component_rect_on_image(image, component, image_width_px, image_height_px)
    rect.set_stroke(color=YELLOW, width=5)
    caption = Text(component.caption, color=WHITE).scale(0.45)
    caption.to_edge(DOWN)
    caption.shift([0, 0.2, 0])
    full_frame_center = scene.camera.frame.get_center()
    full_frame_width = scene.camera.frame.width

    zoom_width = max(rect.width * zoom_padding, 1.2)
    zoom_height = max(rect.height * zoom_padding, 1.0)
    aspect_ratio = config.frame_width / config.frame_height
    target_frame_width = max(zoom_width, zoom_height * aspect_ratio)

    scene.play(Create(rect), run_time=0.35)
    scene.play(
        scene.camera.frame.animate.move_to(rect.get_center()).set(width=target_frame_width),
        image.animate.set_opacity(fade_opacity),
        FadeIn(caption),
        run_time=zoom_duration,
    )
    scene.wait(hold_duration)
    scene.play(
        scene.camera.frame.animate.move_to(full_frame_center).set(width=full_frame_width),
        image.animate.set_opacity(1.0),
        FadeOut(caption),
        FadeOut(rect),
        run_time=zoom_duration,
    )


# Scene: show page image and run component focus for all provided components.
class EditorComponentDemo(MovingCameraScene):
    IMAGE_PATH = "manim/output/editor-1920x1080.jpg"
    COMPONENTS_PATH = "manim/output/editor-components.json"
    MAIN_CAPTION = "maincaptionvar"
    IMAGE_WIDTH_PX = 1920.0
    IMAGE_HEIGHT_PX = 1080.0

    def construct(self) -> None:
        image_path = Path(self.IMAGE_PATH)
        components_path = Path(self.COMPONENTS_PATH)
        if not image_path.exists():
            raise FileNotFoundError(f"Image not found: {image_path}")
        if not components_path.exists():
            raise FileNotFoundError(f"Component data not found: {components_path}")

        components = flatten_components(load_components(str(components_path)))
        image = ImageMobject(str(image_path))
        image.scale_to_fit_width(config.frame_width)
        image.move_to([0, 0, 0])
        self.add(image)

        main_caption = Text(self.MAIN_CAPTION, color=WHITE).scale(0.52)
        main_caption.to_edge(DOWN)
        main_caption.shift([0, 0.25, 0])
        self.play(FadeIn(main_caption), run_time=0.5)

        for component in components:
            focus_component(
                scene=self,
                image=image,
                component=component,
                image_width_px=self.IMAGE_WIDTH_PX,
                image_height_px=self.IMAGE_HEIGHT_PX,
            )

        self.play(FadeOut(main_caption), run_time=0.4)


# Explain pixel coordinate convention expected by this module.
def coordinate_doc() -> str:
    return (
        "Coordinates use screenshot pixels with TOP-LEFT origin. "
        "x grows right; y grows down; w/h are box dimensions. "
        "This follows DOM getBoundingClientRect semantics and is mapped "
        "to Manim's centered scene coordinates internally."
    )


# Render this scene into a movie file path by invoking the manim CLI.
def render_editor_demo(
    output_file: str,
    quality: str = "h",
    preview: bool = False,
    script_path: str = "manim/editor_component_scene.py",
    scene_name: str = "EditorComponentDemo",
) -> None:
    command = ["manim", f"-q{quality}"]
    if preview:
        command.append("-p")
    command.extend(["-o", output_file, script_path, scene_name])
    subprocess.run(command, check=True)
